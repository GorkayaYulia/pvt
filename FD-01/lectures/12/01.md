<a href="02.md">next</a>

<h1>Bubble sorting</h1>

<div>
<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8">(вик)Алгоритм</a> для упорядочивания элементов в списке.

<br/>

Самой простой реализацией считается "Сортировка пузырьком"(bubble sort). Алгоритм носит учебный характер и обычно не применяется на практике.

<br/>

<div>
<strong>Теория:</strong> Сравниваем соседние элементы и если их последовательность нарушена - меняем их местами,
таким образом самый большой элемент "всплывает" в конец массива, от сюда "пузырь".
</div>

<br/>

<div>
<strong>Практика:</strong> <a href="https://codepen.io/paawel/pen/oEwRVQ?editors=0012">реализация</a>
</div>


<br/>

<div>
Разберем по шагам на примере первого массива ([4,5,1,3], в примере реализации есть отображения каждого состояния в консоле):

<ul>
<li>
У нас есть цикл for (внешний), внутри которого еще один цикл (внутренний).
Индекс первого назовем outerIndex (индекс внешнего), второго innerIndex (индекс внутреннего).
Первый цикл будет работать пока индекс меньше длинны входящего массива минус 1,
внутренний пока индекс меньше длинны входящего массива минус 1 минус индекс внешнего массива.
</li>
<li>
Во внутреннем цикле есть условие которое проверяет является ли текущий элемент входящего массива больше следующего элемента.
Если НЕ является, то код просто перейдет к следующей итерации, так как текущий элемент и должен быть меньше следующего.
Если же текущий элемент больше, мы сохранаем следующий элемент в переменную которую называем temp (от temporary - временная),
затем присваиваем следующему элементу (точнее ячейке массива) значение текущего (el + 1 = el), а текущему сохраненное значение следующего.
То есть меняем их местами, а затем переходим к следующей итерации.
</li>
<li>
Проследим первую итерацию. Когда код доходит до условия if происходит проверка arr[innerIndex] > arr[innerIndex+1].
В первой итерации innerIndex равен нулю а innerIndex + 1 равен единице. Подставим значения первого массива и получим проверку:
if (4 > 5). Так как проверка вернет false, то в блок if код не зайдет и мы перейдем к следующей итерации, значение массива не изменится.
</li>
<li>
Проследим вторую итерацию. Когда код доходит до условия if происходит проверка arr[innerIndex] > arr[innerIndex+1].
Во второй итерации innerIndex равен единице а innerIndex + 1 равен двойке. Подставим значения первого массива и получим проверку:
if (5 > 1). Так как проверка вернет true, код попадает в тело if. Переменной temp присваивается innerIndex + 1 (равный двойке),
а значит переменная будет равна 1. Теперь ячейке массива номер 2 (innerIndex + 1) присвоим текущее значение ячейки массива 1 (innerIndex).
В итоге массив в этот самый момент станет выглядеть так: [4,5,5,3]. Теперь текущей ячейке присвоим значение переменной temp
(как видите по состоянию массива на данный момент без переменной temp мы бы затерли текущее значение).
После чего массив станет выглядеть так: [4,1,5,3]. Итак единица и пятерка поменялись местами, что нам и нужно по условиям задачи.
</li>
<li>
На третьей итерации повторится сценарий второй, только уже с числами 5 и 3, после чего массив станет выглядеть так: [4,1,3,5]
</li>
<li>
Все 3 описанные итерации происходили во ВНУТРЕННЕМ цикле, для внешнего цикла это все еще первая итерация,
ко второй итерации ВНЕШНЕГО цикла массив (как уже было описано в прошлом степе) выглядит как: [4,1,3,5]. Дальше все повторится заново.
В первой итерации ВНУТРЕННЕГО цикла на второй итерации ВНЕШНЕГО цикла сравниватся будут 4 и 1, поменяются местами массив станет: [1,4,3,5],
затем сравнятся 4 и 3, массив станет: [1,3,4,5], после чего при всех итерациях ВНЕШНЕГО и ВНУТРЕННЕГО циклов код в блок if уже никак не попадет,
текущее число всегда будет меньше следующего.
</li>
</ul>

</div>

</div>