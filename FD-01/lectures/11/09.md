<a href="10.md">next</a>

<h1>RegExp</h1>

<div>
Может быть создано при помощи литерала - //, или конструктора RegExp. Оператор typeof возвращает object.
</div>

<div>
Простейшим примером РВ может служить проверка совпадения по строке, при такой проверке просто
указывается строка для проверки, например: /test/ или new RegExp(‘test’).
<br/>

<code>var test = new RegExp(‘test’); test.test("adhjsvfs") -> false; test.test("adhjsvfstestkmfksm") -> true;</code>

</div>

<br/>

<div>
Однако как правило требуется проверка совпадения не с конкретным символом (или строкой как последовательностью символов),
 а к примеру с любым символом из конечного набора (либо более сложным условием). Делается это при помощи операторов
класса символов, для чего набор сопоставляемых символов заключается в квадратные скобки ( [] ).
<br/>
Например /[abc]/ означает проверку на наличие одного из 3-х символов a, b или с.
Для примера воспользуемся методом строки search, которая принимает регулярное выражение в качестве аргумента и возвращает индекс в строке
<code>"just some string".search(/[abc]/);</code> <code>"just some string".search(/[omg]/);</code>
<br/>
Если же мы хотим указать совпадение со всеми символами КРОМЕ указанных ставится другой специальный символ: ^
</div>

<br/>

<div>
Еще одной важной возможностью является указание диапазона значений.
К примеру мы хотим установить входит ли буква ‘d’ в диапазон между буквами a и f.
Для этого воспользуемся API объекта RegExp методом test, который вернет нам булев тип.
Затем убедимся, что в заданном диапазоне нету буквы ‘w’.
По мимо test есть метод exec который возвращает первое совпадение, а не булев тип.

<code>/[a-f]/.test('d') -> true; /[a-f]/.test('w') -> false</code>
</div>

<br/>

<div>
Возвращаясь к шаблону проверки строки, если необходимо проверить наличие совпадения не во всей строке,
а только в ее начале или конце для этого существуют специальные символы: ‘^’ (начало строки, символ такой же как и отрицание в наборе символов, только там он внутри [ ], а тут перед строкой), ‘$’ (конец строки)
/^test/ искать в начале строки, /test$/ искать в конце строки, /^test$/ искать по всей строке.
<code>/^test/.test('foofootest'); -> false; /^test/.test('foofootest'); -> true</code>

</div>

<br/>

<div>
Строки и диапазоны можно объединять, к примеру проверим что после буквы ‘a’ идет цифра в диапазоне от 3 до 9 (и саму букву а).
<br/>
<code>/a[3-9]/.test('a4foo'); -> true; /a[3-9]/.test('a2foo'); -> false</code>
</div>

<br/>

<div>
Количество повторений символа можно указать при помощи числа в фигурных скобках, например - {3};
Такое указание именуется квантификатором.
Проверка далее вернет true там, где найдет 3-х значное число.
Для ряда повторяющихся диапазонов существуют специальные классы,
к примеру шаблон поиска цифр [0-9] можно заменить классом “\d” (есть и другие классы, например: \w - латинская буква, цифра или подчеркивание)

<code>/[0-9]{3}/.test('blabla44foofoo555');</code>
<br/>
<code>/\d{5}/.test('foo blabla 33 kabwoo33322'); -> true;  /\d{5}/.test('foo blabla 33 kabwoo3332'); -> false</code>
</div>

<br/>

<div>
Приведенный материал только небольшая часть возможностей регулярных выражений и носит ознакомительный характер, более подробное изучение выходит за рамки курса.
C большОй долей вероятности не понадобится глубоких знаний в этой теме на начальном этапе изучения js или программирование вообще, огромная часть часто используемых шаблонов регулярных выражений легко найти на просторах интернета, либо как часть популярной библиотеки или фреймворка.
К примеру вот так может выглядеть шаблон валидации e-mail (для поля формы)

<code>/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;</code>
</div>

<a href="08.md">prev</a>