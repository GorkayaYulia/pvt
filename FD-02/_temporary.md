<h1>
Inheritance in JavaScript
</h1>

<div>
Каждый объект в js имеет прототип. Связь(доступ) к этому прототипу осуществляется в объекте через скрытое свойство [[Prototype]].
Прототипом будет или объект (на основе которого создан объект) или null если вверх по цепочке таких объектов не осталось.

__proto__ - это ссылка на скрытое свойство объекта [[Prototype]]. Тоесть обратится к [[Prototype]] возможно через свойство __proto__
Все объекты имеют __proto__. При стандартном переборе свойств оно не отображается, однако его значение можно вызвать напрямую или увидеть в консоле.
</div>

<br/>

<div>
Для того чтобы проверить является ли свойство объекта унаследованным или оно определено
в самом объекте существует метод объекта: <code>hasOwnProperty()</code>
</div>

<br/>

<div>
У всех объектов есть свойство Constructor (<code>let test = {}; test.constructor</code>), ссылка на функцию, которая выступила конструктором.
</div>

<br/>

<div>
Конструктором в js называется функция, создающая объект. В случае отсутствия инициализирующих параметров в конструкторе, скобки можно опускать (let test = new Parent).
У Конструктора, тоесть у функции, есть свойство prototype (let ttt = function(){}; у стрелочных не так!). В это свойство можно передать объект, который станет прототипом для экземпляров Конструктора.
</div>

<br/>

<div>
<a href="https://codepen.io/paawel/pen/XZpmdJ?editors=0012">Quick sample</a>
</div>


Тонкий клиент (Thin client) - переносит задачи по обработке информации на сервер
Толстый клиент (Rich client) - производит обработку информации на клиенте, независимо от сервера. При архитектуре Толстого клиента сервер может являться просто хранилищем данных.
При всех плюсах архитектуры Толстого клиента следует все же помнить, что javascript в браузере можно отключить.




///////////////////////////

Redux

Отличная вводная статья по Redux: http://getinstance.info/articles/react/learning-react-redux/
Она же (статья) тезисно:
1. В Реакт данные идут от Родителя к Потомку, это называют “однонаправленным потоком”.
2. Компоненты должны иметь возможность обмениваться данными и в случае когда родитель у них разный, сам Реакт рекомендует для этого использовать Flux архитектуру.
3. Redux это библиотека которая эту самую Flux архитектуру реализует. Основная идея которой хранить состояния ВСЕХ компонентов в одном месте, хранилище (store).
4. Одни компоненты уведомляют Store о изменении состояния, другие подписаны на Store и реагируют на эти изменения. Таким образом, напрямую, между собой компоненты не связаны.
5. FLUX - архитектурный шаблон, REDUX - его реализация.
6. В store всего 4 метода: dispatch, subscribe, getState, replaceReducer. Само хранилище доступно только для чтения и напрямую не меняется, вместо этого измененный объект отправляет action (намерение изменить состояние).
7. Редьюсеры - функции которые принимают action и решают вносить ли изменение в состояние

https://maxfarseer.gitbooks.io/redux-course-ru/content/



///////////////////////////


Cookies
(*вик) Небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя.
До появления Cookie сервер не сохранял никакой информации о клиенте, каждый раз заново идентифицируя клиента. Когда Клиент отправляет запрос на сервер вместе с запросом отправляются и куки относящиеся к запрашиваемому ресурсу. Куки сами по себе это текстовые файлы, которые хранятся на компьютере в директории браузера.

Каждый Браузер установленный на машине пользователя создает свои Куки файлы и чужие (других браузеров) никак не использует.

Посмотреть Куки относящиеся к ресурсу возможно и через webTools
http://www.xiper.net/learn/javascript/cookies/installation-cookies.html

Ограничения на cookies файлы.
Размер куки не может превышать 4кб
От одного домена не может быть установлено более 20 кук
С появлением HTML5 стал доступен новый API (далее в лекции) для работы с данными на стороне Клиента, который, кроме всего прочего, снял и вышеописанные ограничения. Однако не не означает полного отказа от использования Cookies на данный момент.


///////////////////////////

Задача 3-х слов наибольшей длины из произвольной строки

Алгоритм решения
1 Из строки создать массив
2 Сортировать созданный массив
3 Циклом вывести 3 последних элемента созданного и отсортированного массива



///////////////////////////


Поиск простых чисел

https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE

Простое число это число больше 1-цы , которое без остатка делится только на себя и на 1-цу.
К примеру 8 без остатка делится на 4 или 2, следовательно оно составное, 7 ка же без остатка делится только на 7, следовательно оно простое.

Существуют различные алгоритмы поиска, довольно простой описан например на learn.javascript.ru (https://learn.javascript.ru/task/list-primes).

Суть решения заключается в том, чтобы делить текущее число на ряд чисел следующих перед ним, и если остаток от деления на одном из чисел последовательности равен нулю, то число будет составным.

Например.
Скажем в цикле мы проверяем число 6 ( 6 % 5 !==0 ; 6 % 4 !==0;  6 % 3 === 0)
Раз нет остатка от деления значит число составное (не простое).
С числом 7 деление на любое число меньше 7 дает остаток
(кроме 1-цы, но простые числа по определению больше единицы).

На этом алгоритме основано решение, кроме того обратите внимание на метку для continue
(http://javascript.ru/continue)


Существуют и иные алгоритмы и подходы к вычислению простого числа.

Например Решето Эратосфена (https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D0%B5%D1%82%D0%BE_%D0%AD%D1%80%D0%B0%D1%82%D0%BE%D1%81%D1%84%D0%B5%D0%BD%D0%B0)


Суть очень простая, последовательно.
Исключить все четные числа
Исключить каждое 3-е число начиная с 3-х
Исключить каждое 5-е число начиная с 5-ти
Оставшиеся числа будут простыми.

Не обязательно задание: Реализовать Решето Эратосфена на js.


